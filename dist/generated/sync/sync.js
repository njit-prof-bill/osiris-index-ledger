/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.19.1
 * source: sync/sync.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
import * as grpc_1 from "@grpc/grpc-js";
export var sync;
(function (sync) {
    class Null extends pb_1.Message {
        #one_of_decls = [];
        constructor(data) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") { }
        }
        static fromObject(data) {
            const message = new Null({});
            return message;
        }
        toObject() {
            const data = {};
            return data;
        }
        serialize(w) {
            const writer = w || new pb_1.BinaryWriter();
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes) {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Null();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(bytes) {
            return Null.deserialize(bytes);
        }
    }
    sync.Null = Null;
    class Status extends pb_1.Message {
        #one_of_decls = [];
        constructor(data) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("succeeded" in data && data.succeeded != undefined) {
                    this.succeeded = data.succeeded;
                }
            }
        }
        get succeeded() {
            return pb_1.Message.getFieldWithDefault(this, 1, false);
        }
        set succeeded(value) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data) {
            const message = new Status({});
            if (data.succeeded != null) {
                message.succeeded = data.succeeded;
            }
            return message;
        }
        toObject() {
            const data = {};
            if (this.succeeded != null) {
                data.succeeded = this.succeeded;
            }
            return data;
        }
        serialize(w) {
            const writer = w || new pb_1.BinaryWriter();
            if (this.succeeded != false)
                writer.writeBool(1, this.succeeded);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes) {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Status();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.succeeded = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(bytes) {
            return Status.deserialize(bytes);
        }
    }
    sync.Status = Status;
    class TransactionId extends pb_1.Message {
        #one_of_decls = [];
        constructor(data) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("transaction_id" in data && data.transaction_id != undefined) {
                    this.transaction_id = data.transaction_id;
                }
            }
        }
        get transaction_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "");
        }
        set transaction_id(value) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data) {
            const message = new TransactionId({});
            if (data.transaction_id != null) {
                message.transaction_id = data.transaction_id;
            }
            return message;
        }
        toObject() {
            const data = {};
            if (this.transaction_id != null) {
                data.transaction_id = this.transaction_id;
            }
            return data;
        }
        serialize(w) {
            const writer = w || new pb_1.BinaryWriter();
            if (this.transaction_id.length)
                writer.writeString(1, this.transaction_id);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes) {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TransactionId();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.transaction_id = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(bytes) {
            return TransactionId.deserialize(bytes);
        }
    }
    sync.TransactionId = TransactionId;
    class Strategy extends pb_1.Message {
        #one_of_decls = [];
        constructor(data) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("strategy" in data && data.strategy != undefined) {
                    this.strategy = data.strategy;
                }
            }
        }
        get strategy() {
            return pb_1.Message.getFieldWithDefault(this, 1, "");
        }
        set strategy(value) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data) {
            const message = new Strategy({});
            if (data.strategy != null) {
                message.strategy = data.strategy;
            }
            return message;
        }
        toObject() {
            const data = {};
            if (this.strategy != null) {
                data.strategy = this.strategy;
            }
            return data;
        }
        serialize(w) {
            const writer = w || new pb_1.BinaryWriter();
            if (this.strategy.length)
                writer.writeString(1, this.strategy);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes) {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Strategy();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.strategy = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(bytes) {
            return Strategy.deserialize(bytes);
        }
    }
    sync.Strategy = Strategy;
    class Interval extends pb_1.Message {
        #one_of_decls = [];
        constructor(data) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("interval" in data && data.interval != undefined) {
                    this.interval = data.interval;
                }
            }
        }
        get interval() {
            return pb_1.Message.getFieldWithDefault(this, 1, "");
        }
        set interval(value) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data) {
            const message = new Interval({});
            if (data.interval != null) {
                message.interval = data.interval;
            }
            return message;
        }
        toObject() {
            const data = {};
            if (this.interval != null) {
                data.interval = this.interval;
            }
            return data;
        }
        serialize(w) {
            const writer = w || new pb_1.BinaryWriter();
            if (this.interval.length)
                writer.writeString(1, this.interval);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes) {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Interval();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.interval = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(bytes) {
            return Interval.deserialize(bytes);
        }
    }
    sync.Interval = Interval;
    class TransactionIdList extends pb_1.Message {
        #one_of_decls = [];
        constructor(data) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("transaction_list" in data && data.transaction_list != undefined) {
                    this.transaction_list = data.transaction_list;
                }
            }
        }
        get transaction_list() {
            return pb_1.Message.getRepeatedWrapperField(this, TransactionId, 1);
        }
        set transaction_list(value) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data) {
            const message = new TransactionIdList({});
            if (data.transaction_list != null) {
                message.transaction_list = data.transaction_list.map(item => TransactionId.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data = {};
            if (this.transaction_list != null) {
                data.transaction_list = this.transaction_list.map((item) => item.toObject());
            }
            return data;
        }
        serialize(w) {
            const writer = w || new pb_1.BinaryWriter();
            if (this.transaction_list.length)
                writer.writeRepeatedMessage(1, this.transaction_list, (item) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes) {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TransactionIdList();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.transaction_list, () => pb_1.Message.addToRepeatedWrapperField(message, 1, TransactionId.deserialize(reader), TransactionId));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(bytes) {
            return TransactionIdList.deserialize(bytes);
        }
    }
    sync.TransactionIdList = TransactionIdList;
    class Error extends pb_1.Message {
        #one_of_decls = [];
        constructor(data) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("error" in data && data.error != undefined) {
                    this.error = data.error;
                }
            }
        }
        get error() {
            return pb_1.Message.getFieldWithDefault(this, 1, "");
        }
        set error(value) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data) {
            const message = new Error({});
            if (data.error != null) {
                message.error = data.error;
            }
            return message;
        }
        toObject() {
            const data = {};
            if (this.error != null) {
                data.error = this.error;
            }
            return data;
        }
        serialize(w) {
            const writer = w || new pb_1.BinaryWriter();
            if (this.error.length)
                writer.writeString(1, this.error);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes) {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Error();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.error = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(bytes) {
            return Error.deserialize(bytes);
        }
    }
    sync.Error = Error;
    class Limit extends pb_1.Message {
        #one_of_decls = [];
        constructor(data) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("limit" in data && data.limit != undefined) {
                    this.limit = data.limit;
                }
            }
        }
        get limit() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0);
        }
        set limit(value) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data) {
            const message = new Limit({});
            if (data.limit != null) {
                message.limit = data.limit;
            }
            return message;
        }
        toObject() {
            const data = {};
            if (this.limit != null) {
                data.limit = this.limit;
            }
            return data;
        }
        serialize(w) {
            const writer = w || new pb_1.BinaryWriter();
            if (this.limit != 0)
                writer.writeInt32(1, this.limit);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes) {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Limit();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.limit = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(bytes) {
            return Limit.deserialize(bytes);
        }
    }
    sync.Limit = Limit;
    class Conflict extends pb_1.Message {
        #one_of_decls = [];
        constructor(data) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("transaction_id" in data && data.transaction_id != undefined) {
                    this.transaction_id = data.transaction_id;
                }
                if ("conflicting_transaction" in data && data.conflicting_transaction != undefined) {
                    this.conflicting_transaction = data.conflicting_transaction;
                }
                if ("reason" in data && data.reason != undefined) {
                    this.reason = data.reason;
                }
            }
        }
        get transaction_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "");
        }
        set transaction_id(value) {
            pb_1.Message.setField(this, 1, value);
        }
        get conflicting_transaction() {
            return pb_1.Message.getFieldWithDefault(this, 2, "");
        }
        set conflicting_transaction(value) {
            pb_1.Message.setField(this, 2, value);
        }
        get reason() {
            return pb_1.Message.getFieldWithDefault(this, 3, "");
        }
        set reason(value) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data) {
            const message = new Conflict({});
            if (data.transaction_id != null) {
                message.transaction_id = data.transaction_id;
            }
            if (data.conflicting_transaction != null) {
                message.conflicting_transaction = data.conflicting_transaction;
            }
            if (data.reason != null) {
                message.reason = data.reason;
            }
            return message;
        }
        toObject() {
            const data = {};
            if (this.transaction_id != null) {
                data.transaction_id = this.transaction_id;
            }
            if (this.conflicting_transaction != null) {
                data.conflicting_transaction = this.conflicting_transaction;
            }
            if (this.reason != null) {
                data.reason = this.reason;
            }
            return data;
        }
        serialize(w) {
            const writer = w || new pb_1.BinaryWriter();
            if (this.transaction_id.length)
                writer.writeString(1, this.transaction_id);
            if (this.conflicting_transaction.length)
                writer.writeString(2, this.conflicting_transaction);
            if (this.reason.length)
                writer.writeString(3, this.reason);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes) {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Conflict();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.transaction_id = reader.readString();
                        break;
                    case 2:
                        message.conflicting_transaction = reader.readString();
                        break;
                    case 3:
                        message.reason = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(bytes) {
            return Conflict.deserialize(bytes);
        }
    }
    sync.Conflict = Conflict;
    class SyncEvent extends pb_1.Message {
        #one_of_decls = [];
        constructor(data) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("timestamp" in data && data.timestamp != undefined) {
                    this.timestamp = data.timestamp;
                }
                if ("status" in data && data.status != undefined) {
                    this.status = data.status;
                }
            }
        }
        get timestamp() {
            return pb_1.Message.getFieldWithDefault(this, 1, "");
        }
        set timestamp(value) {
            pb_1.Message.setField(this, 1, value);
        }
        get status() {
            return pb_1.Message.getFieldWithDefault(this, 2, "");
        }
        set status(value) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data) {
            const message = new SyncEvent({});
            if (data.timestamp != null) {
                message.timestamp = data.timestamp;
            }
            if (data.status != null) {
                message.status = data.status;
            }
            return message;
        }
        toObject() {
            const data = {};
            if (this.timestamp != null) {
                data.timestamp = this.timestamp;
            }
            if (this.status != null) {
                data.status = this.status;
            }
            return data;
        }
        serialize(w) {
            const writer = w || new pb_1.BinaryWriter();
            if (this.timestamp.length)
                writer.writeString(1, this.timestamp);
            if (this.status.length)
                writer.writeString(2, this.status);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes) {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SyncEvent();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.timestamp = reader.readString();
                        break;
                    case 2:
                        message.status = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(bytes) {
            return SyncEvent.deserialize(bytes);
        }
    }
    sync.SyncEvent = SyncEvent;
    class SyncStatus extends pb_1.Message {
        #one_of_decls = [];
        constructor(data) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("status" in data && data.status != undefined) {
                    this.status = data.status;
                }
                if ("progress" in data && data.progress != undefined) {
                    this.progress = data.progress;
                }
                if ("errors" in data && data.errors != undefined) {
                    this.errors = data.errors;
                }
            }
        }
        get status() {
            return pb_1.Message.getFieldWithDefault(this, 1, "");
        }
        set status(value) {
            pb_1.Message.setField(this, 1, value);
        }
        get progress() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0);
        }
        set progress(value) {
            pb_1.Message.setField(this, 2, value);
        }
        get errors() {
            return pb_1.Message.getRepeatedWrapperField(this, Error, 3);
        }
        set errors(value) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        static fromObject(data) {
            const message = new SyncStatus({});
            if (data.status != null) {
                message.status = data.status;
            }
            if (data.progress != null) {
                message.progress = data.progress;
            }
            if (data.errors != null) {
                message.errors = data.errors.map(item => Error.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data = {};
            if (this.status != null) {
                data.status = this.status;
            }
            if (this.progress != null) {
                data.progress = this.progress;
            }
            if (this.errors != null) {
                data.errors = this.errors.map((item) => item.toObject());
            }
            return data;
        }
        serialize(w) {
            const writer = w || new pb_1.BinaryWriter();
            if (this.status.length)
                writer.writeString(1, this.status);
            if (this.progress != 0)
                writer.writeInt32(2, this.progress);
            if (this.errors.length)
                writer.writeRepeatedMessage(3, this.errors, (item) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes) {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SyncStatus();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.status = reader.readString();
                        break;
                    case 2:
                        message.progress = reader.readInt32();
                        break;
                    case 3:
                        reader.readMessage(message.errors, () => pb_1.Message.addToRepeatedWrapperField(message, 3, Error.deserialize(reader), Error));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(bytes) {
            return SyncStatus.deserialize(bytes);
        }
    }
    sync.SyncStatus = SyncStatus;
    class ConflictResolver extends pb_1.Message {
        #one_of_decls = [];
        constructor(data) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("transaction_id" in data && data.transaction_id != undefined) {
                    this.transaction_id = data.transaction_id;
                }
                if ("resolution_strategy" in data && data.resolution_strategy != undefined) {
                    this.resolution_strategy = data.resolution_strategy;
                }
            }
        }
        get transaction_id() {
            return pb_1.Message.getFieldWithDefault(this, 1, "");
        }
        set transaction_id(value) {
            pb_1.Message.setField(this, 1, value);
        }
        get resolution_strategy() {
            return pb_1.Message.getFieldWithDefault(this, 2, "");
        }
        set resolution_strategy(value) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data) {
            const message = new ConflictResolver({});
            if (data.transaction_id != null) {
                message.transaction_id = data.transaction_id;
            }
            if (data.resolution_strategy != null) {
                message.resolution_strategy = data.resolution_strategy;
            }
            return message;
        }
        toObject() {
            const data = {};
            if (this.transaction_id != null) {
                data.transaction_id = this.transaction_id;
            }
            if (this.resolution_strategy != null) {
                data.resolution_strategy = this.resolution_strategy;
            }
            return data;
        }
        serialize(w) {
            const writer = w || new pb_1.BinaryWriter();
            if (this.transaction_id.length)
                writer.writeString(1, this.transaction_id);
            if (this.resolution_strategy.length)
                writer.writeString(2, this.resolution_strategy);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes) {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ConflictResolver();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.transaction_id = reader.readString();
                        break;
                    case 2:
                        message.resolution_strategy = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(bytes) {
            return ConflictResolver.deserialize(bytes);
        }
    }
    sync.ConflictResolver = ConflictResolver;
    class ConflictList extends pb_1.Message {
        #one_of_decls = [];
        constructor(data) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("conflict_list" in data && data.conflict_list != undefined) {
                    this.conflict_list = data.conflict_list;
                }
            }
        }
        get conflict_list() {
            return pb_1.Message.getRepeatedWrapperField(this, Conflict, 1);
        }
        set conflict_list(value) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data) {
            const message = new ConflictList({});
            if (data.conflict_list != null) {
                message.conflict_list = data.conflict_list.map(item => Conflict.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data = {};
            if (this.conflict_list != null) {
                data.conflict_list = this.conflict_list.map((item) => item.toObject());
            }
            return data;
        }
        serialize(w) {
            const writer = w || new pb_1.BinaryWriter();
            if (this.conflict_list.length)
                writer.writeRepeatedMessage(1, this.conflict_list, (item) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes) {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ConflictList();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.conflict_list, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Conflict.deserialize(reader), Conflict));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(bytes) {
            return ConflictList.deserialize(bytes);
        }
    }
    sync.ConflictList = ConflictList;
    class SyncEventList extends pb_1.Message {
        #one_of_decls = [];
        constructor(data) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("sync_list" in data && data.sync_list != undefined) {
                    this.sync_list = data.sync_list;
                }
            }
        }
        get sync_list() {
            return pb_1.Message.getRepeatedWrapperField(this, SyncEvent, 1);
        }
        set sync_list(value) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data) {
            const message = new SyncEventList({});
            if (data.sync_list != null) {
                message.sync_list = data.sync_list.map(item => SyncEvent.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data = {};
            if (this.sync_list != null) {
                data.sync_list = this.sync_list.map((item) => item.toObject());
            }
            return data;
        }
        serialize(w) {
            const writer = w || new pb_1.BinaryWriter();
            if (this.sync_list.length)
                writer.writeRepeatedMessage(1, this.sync_list, (item) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes) {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SyncEventList();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.sync_list, () => pb_1.Message.addToRepeatedWrapperField(message, 1, SyncEvent.deserialize(reader), SyncEvent));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary() {
            return this.serialize();
        }
        static deserializeBinary(bytes) {
            return SyncEventList.deserialize(bytes);
        }
    }
    sync.SyncEventList = SyncEventList;
    class UnimplementedIndexSynchroService {
        static definition = {
            SyncLedger: {
                path: "/sync.IndexSynchro/SyncLedger",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes) => Null.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes) => Status.deserialize(new Uint8Array(bytes))
            },
            DetectLedgerConflicts: {
                path: "/sync.IndexSynchro/DetectLedgerConflicts",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes) => Null.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes) => ConflictList.deserialize(new Uint8Array(bytes))
            },
            ResolveLedgerConflict: {
                path: "/sync.IndexSynchro/ResolveLedgerConflict",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes) => ConflictResolver.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes) => Status.deserialize(new Uint8Array(bytes))
            },
            BroadcastTransaction: {
                path: "/sync.IndexSynchro/BroadcastTransaction",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes) => TransactionId.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes) => Status.deserialize(new Uint8Array(bytes))
            },
            FetchMissingTransactions: {
                path: "/sync.IndexSynchro/FetchMissingTransactions",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes) => Null.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes) => TransactionIdList.deserialize(new Uint8Array(bytes))
            },
            MonitorLedgerSyncStatus: {
                path: "/sync.IndexSynchro/MonitorLedgerSyncStatus",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes) => Null.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes) => SyncStatus.deserialize(new Uint8Array(bytes))
            },
            ForceLedgerReconciliation: {
                path: "/sync.IndexSynchro/ForceLedgerReconciliation",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes) => Null.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes) => Status.deserialize(new Uint8Array(bytes))
            },
            SetLedgerConflictResolutionStrategy: {
                path: "/sync.IndexSynchro/SetLedgerConflictResolutionStrategy",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes) => Null.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes) => Status.deserialize(new Uint8Array(bytes))
            },
            ScheduleLedgerSync: {
                path: "/sync.IndexSynchro/ScheduleLedgerSync",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes) => Interval.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes) => Status.deserialize(new Uint8Array(bytes))
            },
            ViewLedgerSyncHistory: {
                path: "/sync.IndexSynchro/ViewLedgerSyncHistory",
                requestStream: false,
                responseStream: false,
                requestSerialize: (message) => Buffer.from(message.serialize()),
                requestDeserialize: (bytes) => Limit.deserialize(new Uint8Array(bytes)),
                responseSerialize: (message) => Buffer.from(message.serialize()),
                responseDeserialize: (bytes) => SyncEventList.deserialize(new Uint8Array(bytes))
            }
        };
    }
    sync.UnimplementedIndexSynchroService = UnimplementedIndexSynchroService;
    class IndexSynchroClient extends grpc_1.makeGenericClientConstructor(UnimplementedIndexSynchroService.definition, "IndexSynchro", {}) {
        constructor(address, credentials, options) {
            super(address, credentials, options);
        }
        SyncLedger = (message, metadata, options, callback) => {
            return super.SyncLedger(message, metadata, options, callback);
        };
        DetectLedgerConflicts = (message, metadata, options, callback) => {
            return super.DetectLedgerConflicts(message, metadata, options, callback);
        };
        ResolveLedgerConflict = (message, metadata, options, callback) => {
            return super.ResolveLedgerConflict(message, metadata, options, callback);
        };
        BroadcastTransaction = (message, metadata, options, callback) => {
            return super.BroadcastTransaction(message, metadata, options, callback);
        };
        FetchMissingTransactions = (message, metadata, options, callback) => {
            return super.FetchMissingTransactions(message, metadata, options, callback);
        };
        MonitorLedgerSyncStatus = (message, metadata, options, callback) => {
            return super.MonitorLedgerSyncStatus(message, metadata, options, callback);
        };
        ForceLedgerReconciliation = (message, metadata, options, callback) => {
            return super.ForceLedgerReconciliation(message, metadata, options, callback);
        };
        SetLedgerConflictResolutionStrategy = (message, metadata, options, callback) => {
            return super.SetLedgerConflictResolutionStrategy(message, metadata, options, callback);
        };
        ScheduleLedgerSync = (message, metadata, options, callback) => {
            return super.ScheduleLedgerSync(message, metadata, options, callback);
        };
        ViewLedgerSyncHistory = (message, metadata, options, callback) => {
            return super.ViewLedgerSyncHistory(message, metadata, options, callback);
        };
    }
    sync.IndexSynchroClient = IndexSynchroClient;
})(sync || (sync = {}));
